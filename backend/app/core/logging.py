import logging
from typing import Any

import fastapi
import psycopg
import sqlalchemy
import sqlmodel
import starlette
import structlog
from opentelemetry import trace
from structlog.types import EventDict, Processor

from app.core.config import Settings

# Adapted from: https://wazaari.dev/blog/fastapi-structlog-integration


def add_open_telemetry_spans(logger: Any, method_name: str, event_dict: EventDict) -> EventDict:
    span = trace.get_current_span()
    if type(span) is trace.span.NonRecordingSpan:
        return event_dict

    ctx = span.get_span_context()
    parent = getattr(span, "parent", None)

    event_dict["span"] = {
        "span_id": format(ctx.span_id, "016x"),
        "trace_id": format(ctx.trace_id, "032x"),
        "parent_span_id": None if not parent else format(parent.span_id, "016x"),
    }

    return event_dict


def drop_color_message_key(logger: Any, method_name: str, event_dict: EventDict) -> EventDict:
    """
    Uvicorn logs the message a second time in the extra `color_message`, but we don't
    need it. This processor drops the key from the event dict if it exists.
    """
    event_dict.pop("color_message", None)
    return event_dict


def setup_logging(settings: Settings) -> None:
    if settings.log.format == "console":
        timestamper = structlog.processors.TimeStamper(fmt="%Y-%m-%d %H:%M:%S", utc=False)
    else:
        timestamper = structlog.processors.TimeStamper(fmt="iso")

    shared_processors: list[Processor] = [
        structlog.contextvars.merge_contextvars,
        add_open_telemetry_spans,
        structlog.stdlib.add_logger_name,
        structlog.stdlib.add_log_level,
        structlog.stdlib.PositionalArgumentsFormatter(),
        structlog.stdlib.ExtraAdder(),
        drop_color_message_key,
        timestamper,
        structlog.processors.StackInfoRenderer(),
    ]

    if settings.log.format != "console":
        # Format the exception json and logfmt logs, as we want to pretty-print them when
        # using the ConsoleRenderer
        shared_processors.append(structlog.processors.format_exc_info)

    structlog.configure(
        processors=[*shared_processors, structlog.stdlib.ProcessorFormatter.wrap_for_formatter],
        logger_factory=structlog.stdlib.LoggerFactory(),
        cache_logger_on_first_use=True,
    )

    log_renderer: structlog.types.Processor
    if settings.log.format == "json":
        log_renderer = structlog.processors.JSONRenderer()
    elif settings.log.format == "logfmt":
        log_renderer = structlog.processors.LogfmtRenderer()
    else:
        log_renderer = structlog.dev.ConsoleRenderer(
            exception_formatter=structlog.dev.RichTracebackFormatter(
                width=-1,
                suppress=[fastapi, psycopg, sqlalchemy, sqlmodel, starlette],
            )
        )

    formatter = structlog.stdlib.ProcessorFormatter(
        # These run ONLY on `logging` entries that do NOT originate within
        # structlog.
        foreign_pre_chain=shared_processors,
        # These run on ALL entries after the pre_chain is done.
        processors=[
            # Remove _record & _from_structlog.
            structlog.stdlib.ProcessorFormatter.remove_processors_meta,
            log_renderer,
        ],
    )

    # Reconfigure the root logger to use our structlog formatter,
    # effectively emitting the logs via structlog
    handler = logging.StreamHandler()
    handler.setFormatter(formatter)
    root_logger = logging.getLogger()
    root_logger.addHandler(handler)
    root_logger.setLevel(settings.log.level)

    # Make sure logs generated by uvicorn are only handled by the root logger
    for _logger in ["uvicorn", "uvicorn.error", "uvicorn.access"]:
        # Remove existing handlers, to prevent logs from being output twice
        logging.getLogger(_logger).handlers.clear()
        # Propagate logs up to the root logger
        logging.getLogger(_logger).propagate = True

    if not settings.log.access_log:
        logging.getLogger("uvicorn.access").disabled = True
